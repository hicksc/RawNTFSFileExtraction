diff -x '*.[oda18]' -x config.log -r qemu-2.1+dfsg/block/linux-aio.c qemu-2.1+dfsg-working/block/linux-aio.c
17a18,21
> #include <syslog.h>
> #include <sys/socket.h>
> extern int write_log_socket;
> 
79a84,94
>             }
>         }
> 
>         /* Write-log patch, if the local uds socket is valid, write the offset and number of bytes to the socket. */
>         if (write_log_socket != -1 && ret == 0 && laiocb->iocb.aio_lio_opcode == IO_CMD_PWRITE) {
>             int64_t d[2];
>             d[0] = laiocb->iocb.u.c.offset;
>             d[1] = laiocb->iocb.u.c.nbytes;
>             if (send(write_log_socket, (void *)&d, sizeof(d), 0) < 0) {
>                 syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to log write in qemu_laio_process_completion: %m");
>                 syslog(LOG_DEBUG | LOG_USER, "write_log_socket =: %d", write_log_socket);

diff -x '*.[oda18]' -x config.log -r qemu-2.1+dfsg/block/raw-posix.c qemu-2.1+dfsg-working/block/raw-posix.c
33a34,38
> /* Extra includes and global variable for write log modification */
> #include <syslog.h>
> #include <sys/socket.h>
> extern int write_log_socket;
> 
diff -x '*.[oda18]' -x config.log -r qemu-2.1+dfsg/block.c qemu-2.1+dfsg-working/block.c
52a53,58
> /* Extra includes for write log ptch modification, write_log_socket without extern configured here */
> #include <syslog.h>
> #include <sys/socket.h>
> #include <inttypes.h>
> int write_log_socket = -1;
> 
2228c2234
<     
---
> 
2764a2771,2772
>     /* Debug syslog to figure out which method to tap the write offset from */
>     syslog(LOG_DEBUG | LOG_USER, "write_log: in bdrv_raw_co method. is_write = %s", is_write ? "true" : "false");
2805a2814,2815
>   -
>   Method write log modified to write offset and length to UDS.
2810c2820,2834
<     return bdrv_rw_co(bs, sector_num, (uint8_t *)buf, nb_sectors, true, 0);
---
>     syslog(LOG_DEBUG | LOG_USER, "write_log: in bdrv_write method.");
>     int ret;
>     ret = bdrv_rw_co(bs, sector_num, (uint8_t *)buf, nb_sectors, true, 0);
> 
>      if (write_log_socket != 1 && ret >= 0) {
>         int64_t d[2];
>         d[0] = sector_num * 512;
>         d[1] = nb_sectors * 512;
>         syslog(LOG_DEBUG | LOG_USER, "write_log: write to sector number: %" PRIx64, sector_num);
>         if (send(write_log_socket, (void *)&d, sizeof(d), 0) < 0) {
>             syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to log write in bdrv_write: %m");
>         }
>      }
> 
>     return ret;
2904a2929,2930
>     /* Debug syslog to figure out which method to tap the write offset from */
>     syslog(LOG_DEBUG | LOG_USER, "write_log: in bdrv_pwrite method");
2927a2954,2955
>     /* Debug syslog to figure out which method to tap the write offset from */
>     syslog(LOG_DEBUG | LOG_USER, "write_log: in bdrv_pwrite_sync method");
4142a4171,4172
>     /* Debug syslog to figure out which method to tap the write offset from */
>     syslog(LOG_DEBUG | LOG_USER, "write_log: in bdrv_write_compressed method");
4379a4410,4420
>     /* Debug syslog to figure out which method to tap the write offset from */
>     syslog(LOG_DEBUG | LOG_USER, "write_log: in bdrv_aio_writev method");
> 
>     if (write_log_socket != 1) {
>         int64_t d[2];
>         d[0] = sector_num * 512;
>         d[1] = nb_sectors * 512;
>         if (send(write_log_socket, (void *)&d, sizeof(d), 0) < 0) {
>             syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to log write in bdrv_write: %m");
>         }
>      }
4627a4669
> 
4885a4928,4939
>     /* Debug syslog to figure out which method to tap the write offset from */
>     syslog(LOG_DEBUG | LOG_USER, "write_log: in coroutine_fn bdrv_co_writev_em method");
> 
>     if (write_log_socket != 1) {
>         int64_t d[2];
>         d[0] = sector_num * 512;
>         d[1] = nb_sectors * 512;
>         if (send(write_log_socket, (void *)&d, sizeof(d), 0) < 0) {
>             syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to log write in bdrv_write: %m");
>         }
>      }

diff -x '*.[oda18]' -x config.log -r qemu-2.1+dfsg/vl.c qemu-2.1+dfsg-working/vl.c
126a127,134
> /* Write patch extra includes and definitions for sending a datagram with the block device offset and the number of bytes
> written concatenated together as machine-native 64-bit ints */
> #include <syslog.h>
> #include <sys/socket.h>
> #include <sys/un.h>
> extern int write_log_socket;
> struct sockaddr_un write_log_name = { AF_UNIX, "\x00" };
> 
2908c2916
< int main(int argc, char **argv, char **envp)
---
> int main(int argc, char *argv[], char **envp)
2909a2918,2925
>     /* Wite log patch: Some debug stuff to figure out where to place subsequent code.*/
>     syslog(LOG_DEBUG | LOG_USER, "Log-writes patch. QEMU in it's main method.");
>     /*syslog(LOG_DEBUG | LOG_USER, "Log-writes patch. QEMU nArgs: %d.", argc);
>     int countArgv;
>     for(countArgv = 0; countArgv < argc; countArgv++) {
>         syslog( LOG_DEBUG | LOG_USER, "%s, ", argv[countArgv] );
>     } */
> 
3057a3074
> 
3848a3866,3869
>                 syslog(LOG_DEBUG | LOG_USER, "QEMU_OPTION_xen_domid = %d.", xen_domid);
>                 // snprintf(write_log_name.sun_path, sizeof(write_log_name.sun_path), "/var/run/diskwatch-%s", optarg);
>                 snprintf(write_log_name.sun_path, sizeof(write_log_name.sun_path), "/var/run/diskwatch");
>                 syslog(LOG_DEBUG | LOG_USER, "QEMU Write patch log dom socket = %s.", write_log_name.sun_path);
3855a3877
>                 syslog(LOG_DEBUG | LOG_USER, "QEMU_OPTION_xen_create.");
3968a3991,4016
>     } // End of for(;;) option parsing loop.
> 
>     /* Write log patch: Create socket to local datagram UDS */
>     if (write_log_name.sun_path[0]) { // Provided we have set the datasocket node.
>         int flags;
> 
>         if ((write_log_socket = socket(AF_UNIX, SOCK_DGRAM, 0)) < 0) { // Get the socket.
>             syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to create socket: %m");
>         }
> 
>         if ((flags = fcntl(write_log_socket, F_GETFL, 0)) < 0) { // Get the socket flags.
>             syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to get socket flags: %m");
>         } else {
>             if (fcntl(write_log_socket, F_SETFL, O_NONBLOCK | flags) < 0) { // Set the socket flags.
>             syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to set socket flags: %m");
>             }
>         }
> 
>         write_log_name.sun_family = AF_UNIX; // sun_family always = AF_UNIX for UNIX domain sockets.
>         if (connect(write_log_socket, &write_log_name, sizeof(write_log_name)) < 0) { // Connect to the domain  socket.
>             syslog(LOG_DEBUG | LOG_USER, "write_log: Failed to connect: %m");
>             close(write_log_socket);
>             write_log_socket = -1;
>         }
>     } else {
>         syslog(LOG_DEBUG | LOG_USER, "write_log: UNIX Domain socket path set.");
3970d4017
<     loc_set_none();
3971a4019
>     loc_set_none();
4339a4388
>     syslog(LOG_DEBUG | LOG_USER, "QEMU opening virtual block devices.");
